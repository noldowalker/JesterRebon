# Архитектура боевого уровня

У боевой сцены есть корневой объект, который должен носить название BootAndRoot.
Все содержимое сцены помещается как дочерние объекты:

![img.png](./Img/level_boot_and_root_in_hierarchy.png)

Сам объект в качестве компонентов содержит Основную систему уровня, Глобальные системы и Контейнер для инверсии зависимостей.

![img.png](./Img/level_boor_and_root_example.png)

## Контейнер инверсии зависимостей
Реализация наследника LifetimeScope для конкретной сцены в рамках [vContainer](https://vcontainer.hadashikick.jp/)
Для каждого типа проброса зависимостей выделены свои регионы, пожалуйста соблюдаем их. Если появилась новая категоряи объектов, выделяем для нее отдельную зону.


Собирает и пробрасывает все зависимости в иерархии, для которых у него указано

    builder.RegisterComponentInHierarchy<Объект_участвующий_в_DI>();

Все необходимые для работы уровня ScriptableObjects должны передаваться через внешние поля данного объекта.
Таким образом сразу становистя понятно, какие ресурсы использует данный уровень, а так же их замену для будет осуществить
весьма просто и в одном месте. 

    public class SceneContext : LifetimeScope
    {
            [SerializeField] private SomeScriptableObject someScriptableObject;
    
            protected override void Configure(IContainerBuilder builder)
            {
                //...
                
                #region Scriptable Objects for Injection
        
                builder.RegisterInstance(someScriptableObject);
        
                #endregion Scriptable Objects for Injection
                
                //...
            }  
    }

Для классов создаваемых на сцене через конструктор и пробрасываемых через DI срок жизни (Lifetime) устанавливаем как Scope и тогда экземпляр будет уничтожаться с уничтожением конневого объекта сцены.

## Основная система уровня

Основная система игры. Именно через нее определяется порядок и взаимосвязи между разными аспектами игрового процесса. Отвечает за:
1. Инициацию сцены. Для этого выделен отдельный метод, который срабатывает через некоторое время после Start, чтобы у всех объектов отработали их методы Start() и Awake().
В этом методе вызываются поочередно инициализующие методы всех глобальных систем в нужном порядке, т.к. одни могут зависеть от готовности других. Например для системы контроля врагов нужны данные из сисетмы окружения по допустимым точкам спавна врагов.
2. Ход игрового процесса. Update/FixedUpdate может быть заполнен только здесь. Внутри Update вызываются методы обработки для разных систем в понятном порядке.
3. Игровые события (Actions, Events) которые требуют обмена данными за рамками одной системы должны обрабатываться тоже только здесь и перенаправляться в соответствующие системы главной. Иначе может возникнуть проблема огромного количества подписок между разными системами в том числе по цепочкам, которые сложно отследить.

## Глобальные системы

Глобальные системы это системы котоыре существуют в единственном экземпляре и контролируют свой аспект геймплея. Например: система интерфейса, система звука, система контроля врагов, система управления персонажем игрока и т.д. Каждая из них должна:
1. Наследоваться от BaseSystem
2. Присоединена к корневому объекту как компонент
3. Быть добавлена в контейнер в DI-контейнере

   `builder.RegisterComponentInHierarchy<AnotherOneGlobalSystem>();`
4. После этого ее можно использовать ТОЛЬКО в LevelSystem, который контролирует весь пайплайн уровня (см. Основная система уровня). 

   `[Inject] private AnotherOneGlobalSystem _anotherOneGlobalSystem;`

[На главную](../../README.md)
